-- 주문 일시, 지불유형 별 주문금액
SELECT
	t1.ORD_DT
	, t1.PAY_TP
	, sum(t1.ORD_AMT) ORD_AMT 
FROM T_ORD t1
WHERE t1.ord_st = 'COMP'
GROUP BY t1.ORD_DT, t1.PAY_TP
ORDER BY t1.ORD_DT, t1.PAY_TP;

-- 집계함수는 group by 없이도 사용할 수 있지만, 집계함수를 사용하지 않은 컬럼은 select 절에서 같이 사용할 수 없다.
SELECT 
	count(*)
	, sum(t1.ORD_AMT) TTL_ORD_AMT
	, min(t1.ORD_SEQ) MIN_ORD_SEQ
	, max(t1.ORD_SEQ) MAX_ORD_SEQ
FROM T_ORD t1
WHERE t1.ORD_DT >= TO_DATE('20170101', 'YYYYMMDD')
AND t1.ORD_DT < TO_DATE('20170201', 'YYYYMMDD');

-- 에러가 나는 SQL, t1_ORD_ST 로 group by 를 하거나, t1_ORD_ST 도 집계처리 해야한다.
SELECT
	t1.ORD_ST
	 count(*)
	, sum(t1.ORD_AMT) TTL_ORD_AMT
	, min(t1.ORD_SEQ) MIN_ORD_SEQ
	, max(t1.ORD_SEQ) MAX_ORD_SEQ
FROM T_ORD t1
WHERE t1.ORD_DT >= TO_DATE('20170101', 'YYYYMMDD')
AND t1.ORD_DT < TO_DATE('20170201', 'YYYYMMDD');

-- Group by 컬럼을 변형할 수도 있다. (비슷하게 order by 에서도 사용 가능)
-- 주문금액 타입을 가격에 따라 3종류로 나누어, 해당 종류로 Group by 하는 쿼리 
-- 그러나 ORD_AMT 의 가격 기준이 변경되면 SQL 도 수정해야 하기 때문에, 일회성 쿼리일 때만 사용하도록 한다.
SELECT
	t1.ORD_ST
	, CASE WHEN t1.ORD_AMT >= 5000 THEN 'High Order'
		WHEN t1.ORD_AMT >= 3000 THEN 'Middle Order'
		ELSE 'Low Order' END ORD_AMT_TP
	, COUNT(*) ORD_CNT
FROM T_ORD t1
GROUP BY t1.ORD_ST,
CASE WHEN t1.ORD_AMT >= 5000 THEN 'High Order'
		WHEN t1.ORD_AMT >= 3000 THEN 'Middle Order'
		ELSE 'Low Order' END
ORDER BY 1, 2;

-- 주문년월, 지불유형 별 주문건수
SELECT
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, t1.PAY_TP
	, count(*) ORD_DNT
FROM T_ORD t1
GROUP BY
	TO_CHAR(t1.ORD_DT, 'YYYYMM'),
	t1.PAY_TP
ORDER BY 1, 2;

-- 집계함수 내부에서 CASE 문 활용하기
-- 주문년월별 계좌이체건수/카드결제건
SELECT
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, SUM(CASE WHEN t1.PAY_TP = 'BANK' THEN 1 END) BANK_PAY_CNT
	, sum(CASE WHEN t1.PAY_TP = 'CARD' THEN 1 end) CARD_PAY_CNT
FROM T_ORD t1
WHERE t1.ORD_ST = 'COMP'
GROUP BY TO_CHAR(t1.ORD_DT, 'YYYYMM') 
;
-- 지불유형을 가로(row), 주문년월을 세로(col)
SELECT
	t1.PAY_TP
	,COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201701' THEN 'X' END) ORD_CNT_201701
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201702' THEN 'X' END) ORD_CNT_201702
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201703' THEN 'X' END) ORD_CNT_201703
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201704' THEN 'X' END) ORD_CNT_201704
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201705' THEN 'X' END) ORD_CNT_201705
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201706' THEN 'X' END) ORD_CNT_201706
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201707' THEN 'X' END) ORD_CNT_201707
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201708' THEN 'X' END) ORD_CNT_201708
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201709' THEN 'X' END) ORD_CNT_201709
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201710' THEN 'X' END) ORD_CNT_201710
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201711' THEN 'X' END) ORD_CNT_201711
	, COUNT(CASE WHEN TO_CHAR(t1.ORD_DT, 'YYYYMM') = '201712' THEN 'X' END) ORD_CNT_201712
FROM T_ORD t1
WHERE t1.ORD_ST = 'COMP'
GROUP BY t1.PAY_TP
ORDER BY t1.PAY_TP;

SELECT 
	t2.PAY_TP
	, MAX(CASE WHEN t2.ORD_YM = '201701' THEN t2.ORD_CNT END) ORD_CNT_201701
	, MAX(CASE WHEN t2.ORD_YM = '201702' THEN t2.ORD_CNT END) ORD_CNT_201702
	, MAX(CASE WHEN t2.ORD_YM = '201703' THEN t2.ORD_CNT END) ORD_CNT_201703
	, MAX(CASE WHEN t2.ORD_YM = '201704' THEN t2.ORD_CNT END) ORD_CNT_201704
	, MAX(CASE WHEN t2.ORD_YM = '201705' THEN t2.ORD_CNT END) ORD_CNT_201705
	, MAX(CASE WHEN t2.ORD_YM = '201706' THEN t2.ORD_CNT END) ORD_CNT_201706
	, MAX(CASE WHEN t2.ORD_YM = '201707' THEN t2.ORD_CNT END) ORD_CNT_201707
	, MAX(CASE WHEN t2.ORD_YM = '201708' THEN t2.ORD_CNT END) ORD_CNT_201708
	, MAX(CASE WHEN t2.ORD_YM = '201709' THEN t2.ORD_CNT END) ORD_CNT_201709
	, MAX(CASE WHEN t2.ORD_YM = '201710' THEN t2.ORD_CNT END) ORD_CNT_201710
	, MAX(CASE WHEN t2.ORD_YM = '201711' THEN t2.ORD_CNT END) ORD_CNT_201711
	, MAX(CASE WHEN t2.ORD_YM = '201712' THEN t2.ORD_CNT END) ORD_CNT_201712
FROM (
	SELECT 
		t1.PAY_TP PAY_TP
		, TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
		, count(*) ORD_CNT
	FROM T_ORD t1
	WHERE t1.ORD_ST = 'COMP'
	GROUP BY t1.PAY_TP, TO_CHAR(t1.ORD_DT, 'YYYYMM')
) t2
GROUP BY t2.PAY_TP;

-- COUNT(*) 과 COUNT(COL) 의 차이
-- count(col) 은 null 값 카운트하지 않음
-- outer join 시 유의해야한다.
SELECT
	COUNT(COL1) CNT_COL1
	, COUNT(COL2) CNT_COL2
	, COUNT(COL3) CNT_COL3
FROM (
	SELECT 'A' COL1, NULL COL2, 'C' COL3 FROM dual UNION ALL
	SELECT 'B' Col1, NULL COL2, NULL COL3 FROM dual
);
--count(*) 은 null 값 카운트
SELECT count(COL1) CNT_COL1, count(*) CNT_ALL
FROM (
	SELECT NULL COL1 FROM dual UNION ALL
	SELECT NULL COL1 FROM dual
);

-- 중복 제거 count: COUNT(DISTINCT col)
-- 주문년월별 주문 고객 수(중복제거)
SELECT 
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, COUNT(DISTINCT t1.CUS_ID) CNT_CUS
	, COUNT(*) ORD_CNT
FROM T_ORD t1
WHERE 
	T1.ORD_DT >= TO_DATE('20170101', 'YYYYMMDD') 
	AND t1.ORD_DT < TO_DATE('20170401', 'YYYYMMDD')
GROUP BY TO_CHAR(t1.ORD_DT, 'YYYYMM')
ORDER BY TO_CHAR(t1.ORD_DT, 'YYYYMM');

-- Distinct 를 두 개의 컬럼에서 사용하려면 concat 하여 처리한다.
-- ORD_ST 와 PAY_TP 의 조합에 대한 종류 수
SELECT
	COUNT(DISTINCT t1.ORD_ST || '-' || t1.PAY_TP)
FROM T_ORD t1;
-- 인라인 뷰로 해결하는 방법
SELECT 
	count(*)
FROM (
	SELECT 
		DISTINCT t1.ORD_ST
		, t1.PAY_TP
	FROM T_ORD t1
);

-- Having: Group by 가 수행된 결과 집합에 조건을 줄 때 사용한다.
-- 고객ID, 지불유형별 주문 금액이 10,000 이상인 데이터
-- Having 도 select 와 마찬가지로, group by 이거, 집계함수처리를 한 컬럼만 사용 가능하다.
SELECT 
	t1.CUS_ID 
	, t1.PAY_TP
	, SUM(t1.ORD_AMT) ORD_TTL_AMT
FROM T_ORD t1
WHERE t1.ORD_ST = 'COMP'
GROUP BY t1.CUS_ID , t1.PAY_TP
HAVING SUM(t1.ORD_AMT) >= 10000
ORDER BY sum(t1.ORD_AMT) ASC;
-- 인라인 뷰에서 group by 하고, 바깥에서 where 로 처리할 수도 있다.
SELECT
	*
FROM (
	SELECT 
		t1.CUS_ID
		, t1.PAY_TP
		, SUM(t1.ORD_AMT) ORD_TTL_AMT
	FROM T_ORD t1
	GROUP BY t1.CUS_ID, t1.PAY_TP
) WHERE ORD_TTL_AMT >= 10000
ORDER BY ORD_TTL_AMT ASC;

-- Rollup: 소계와 전체합계 구하기
-- Rollup(A, B, C) = Group by 된 (A+B+C) 별 데이터 - (A+B)별 소계 데이터 - A별 소계 데이터 - 전체합계
-- Rollup인자 순서 중요
SELECT
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, t1.CUS_ID
	, SUM(t1.ORD_AMT) ORD_AMT 
FROM T_ORD t1
WHERE
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_DATE('20170501', 'YYYYMMDD')
GROUP BY
	ROLLUP (TO_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID)
	ORDER BY TO_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID;
	
-- Grouping 함수: Rollup 처리됐는지 여부를 반환하는 함수
-- Rollup 은 소계 데이터에서 null 처리를 하는데, 이것이 원래 null 인 데이터인지 소계되어 null 인지 구분할 때 사용한다.(return 1, 0)
SELECT
	t1.ORD_ST
	, GROUPING(t1.ORD_ST) GR_ORD_ST
	, t1.PAY_TP 
	, GROUPING(t1.PAY_TP) GR_PAY_TP
	, count(*) ORD_CNT
FROM T_ORD t1
GROUP BY rollup(t1.ORD_ST, t1.PAY_TP);
-- 다른 값으로 치환할 때 반드시 GROUPING 을 사용해야 한다.
SELECT 
	CASE WHEN GROUPING(t1.ORD_ST) = 1 THEN 'Total' ELSE t1.ORD_ST END ORD_ST
	, CASE WHEN GROUPING(t1.PAY_TP) = 1 THEN 'Total' ELSE t1.PAY_TP END ORD_ST
	, count(*) ORD_CNT
FROM T_ORD t1
GROUP BY ROLLUP(t1.ORD_ST, t1.PAY_TP)
ORDER BY t1.ORD_ST, t1.PAY_TP;

-- Rollup 컬럼 선택: 특정컬럼 소계/전체합계만 추가
-- 주문년월별/지역별/고객등급별 주문금액 소계 
SELECT
	CASE WHEN grouping(TO_CHAR(t2.ORD_DT, 'YYYYMM')) = 1 THEN 'Total' 
		ELSE TO_CHAR(t2.ORD_DT, 'YYYYMM') END ORD_YM
	, CASE WHEN grouping(t1.RGN_ID) = 1 THEN 'Total' ELSE t1.RGN_ID END RGN_ID
	, CASE WHEN grouping(t1.CUS_GD) = 1 THEN 'Total' ELSE t1.CUS_GD END CUS_GD
	, SUM(t2.ORD_AMT) ORD_AMT 
FROM M_CUS t1, T_ORD t2
WHERE
	t1.CUS_ID = t2.CUS_ID 
	AND t2.ORD_DT >= TO_DATE('20170201', 'YYYYMMDD')
	AND t2.ORD_DT < TO_DATE('20170401', 'YYYYMMDD')
	AND t1.RGN_ID IN ('A', 'B')
--GROUP BY ROLLUP(TO_CHAR(t2.ORD_DT, 'YYYYMM'), t1.RGN_ID, t1.CUS_GD)
--GROUP BY TO_CHAR(t2.ORD_DT, 'YYYYMM'), ROLLUP (t1.RGN_ID, t1.CUS_GD)
--GROUP BY ROLLUP((TO_CHAR(t2.ORD_DT, 'YYYYMM'), t1.RGN_ID, t1.CUS_GD)) -- 괄호 친 컬럼들을 하나로 보고 소계한다. 즉, 전체 합계만 추가된다.
GROUP BY ROLLUP(TO_CHAR(t2.ORD_DT, 'YYYYMM'), (t1.RGN_ID, t1.CUS_GD)) -- ROLLUP 내부 괄호에 따라 소계 변경된다.
ORDER BY TO_CHAR(t2.ORD_DT, 'YYYYMM'), t1.RGN_ID, t1.CUS_GD;

-- Rollup 대체
SELECT 
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, t1.CUS_ID 
	, SUM(t1.ORD_AMT) ORD_AMT 
FROM T_ORD t1
WHERE
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
GROUP BY ROLLUP(TO_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID);
-- 1. union all
-- T_ORD 에 3번 접근하므로 성능상 손해, 컬럼 순서를 맞춰줘야 한다.
SELECT 
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, t1.CUS_ID
	, SUM(t1.ORD_AMT) ORD_AMT
FROM T_ORD t1
where
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
GROUP BY TO_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID
UNION ALL 
SELECT
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, 'Total' CUS_ID
	, SUM(t1.ORD_AMT) ORD_AMT
FROM T_ORD t1
WHERE
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
GROUP BY TO_CHAR(t1.ORD_DT, 'YYYYMM')
UNION ALL 
SELECT 
	'Total' ORD_YM
	, 'Total' CUS_ID 
	, SUM(t1.ORD_AMT) ORD_AMT
FROM T_ORD t1
where
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
;
-- 2. cartesian join, T_ORD 의 결과를 3배로 만들어서 처리한다.
-- T_ORD 의 데이터가 너무 많으면 조인 과정에서 성능 저하가 발생할 수 있다.
-- SQL 이 너무 복잡하다.
SELECT
	CASE WHEN t2.RNO = 1 THEN TO_CHAR(t1.ORD_DT, 'YYYYMM')
		WHEN t2.RNO = 2 THEN TO_CHAR(t1.ORD_DT, 'YYYYMM')
		WHEN t2.RNO = 3 THEN 'Total' END ORD_YM
	, CASE WHEN t2.RNO = 1 THEN t1.CUS_ID 
		WHEN t2.RNO = 2 THEN 'Total'
		WHEN t2.RNO = 3 THEN 'Total' END CUS_ID
	, SUM(t1.ORD_AMT) ORD_AMT
FROM T_ORD t1, ( SELECT ROWNUM RNO FROM DUAL CONNECT BY ROWNUM <= 3 ) t2
WHERE
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
GROUP BY
	CASE WHEN t2.RNO = 1 THEN TO_CHAR(t1.ORD_DT, 'YYYYMM')
		WHEN t2.RNO = 2 THEN TO_CHAR(t1.ORD_DT, 'YYYYMM')
		WHEN t2.RNO = 3 THEN 'Total' END
	, CASE WHEN t2.RNO = 1 THEN t1.CUS_ID 
		WHEN t2.RNO = 2 THEN 'Total'
		WHEN t2.RNO = 3 THEN 'Total' END;
-- 3. with + union all
WITH T_RES AS (
	SELECT
		TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
		, t1.CUS_ID
		, SUM(t1.ORD_AMT) ORD_AMT
	FROM T_ORD t1
	WHERE 
		t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
		AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
		AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
	GROUP BY to_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID
)
SELECT
	t1.ORD_YM
	, t1.CUS_ID 
	, t1.ORD_AMT
FROM T_RES t1
UNION ALL 
SELECT
	t1.ORD_YM 
	, 'Total'
	, SUM(t1.ORD_AMT) ORD_AMT
FROM T_RES t1
GROUP BY t1.ORD_YM 
UNION ALL 
SELECT 
	'Total'
	, 'Total' 
	, SUM(t1.ORD_AMT) ORD_AMT 
FROM T_RES t1;

-- Cube: 조합 가능한 모든 소계
-- 성능상 좋지 못하기 때문에, Rollup 과 Union all, with 등으로 해결할 수 있는지 고민해본다.
SELECT 
	CASE WHEN GROUPING(t1.ORD_ST) = 1 THEN 'Total' ELSE t1.ORD_ST END ORD_ST
	, CASE WHEN GROUPING(TO_CHAR(t1.ORD_DT, 'YYYYMM')) = 1 THEN 'Total' ELSE TO_CHAR(t1.ORD_DT, 'YYYYMM') END ORD_YM
	, CASE WHEN GROUPING(t1.CUS_ID) = 1 THEN 'Total' ELSE t1.CUS_ID END CUS_ID 
	, sum(t1.ORD_AMT) ORD_AMT
FROM T_ORD t1
WHERE 
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
GROUP BY cube(t1.ORD_ST, TO_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID)
ORDER BY t1.ORD_ST, TO_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID;
	
-- grouping set
SELECT 
	TO_CHAR(t1.ORD_DT, 'YYYYMM') ORD_YM
	, t1.CUS_ID
	, count(*) ORD_CNT
	, SUM(t1.ORD_AMT) ORD_AMT
FROM T_ORD t1
WHERE 
	t1.CUS_ID IN ('CUS_0001', 'CUS_0002')
	AND t1.ORD_DT >= TO_DATE('20170301', 'YYYYMMDD')
	AND t1.ORD_DT < TO_Date('20170501', 'YYYYMMDD')
GROUP BY GROUPING SETS (
	(TO_CHAR(t1.ORD_DT, 'YYYYMM'), t1.CUS_ID ) -- GROUP BY 기본 데이
	, (TO_CHAR(t1.ORD_DT, 'YYYYMM')) -- 주문년월별 소계 
	, (T1.CUS_ID) -- 고객별 소계 
	, () -- 전체 합
);
